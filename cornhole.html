<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calibrated 3D Motion Cornhole</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: Arial, sans-serif;
            overflow: hidden;
            touch-action: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
            pointer-events: none;
        }
        
        #score {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        #status {
            font-size: 18px;
            margin-bottom: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 10px;
        }
        
        #instructions {
            font-size: 14px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
        }
        
        #debug {
            font-size: 12px;
            background: rgba(0,0,0,0.5);
            padding: 8px;
            border-radius: 5px;
            max-height: 80px;
            overflow-y: auto;
        }
        
        #startButton, #calibrateButton {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
            color: white;
            border: none;
            padding: 20px 40px;
            font-size: 18px;
            border-radius: 15px;
            cursor: pointer;
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
            z-index: 200;
            pointer-events: auto;
            transition: all 0.3s ease;
        }
        
        #calibrateButton {
            background: linear-gradient(45deg, #4ECDC4, #45B7D1);
        }
        
        #startButton:hover, #calibrateButton:hover {
            transform: translate(-50%, -50%) scale(1.05);
            box-shadow: 0 12px 24px rgba(0,0,0,0.4);
        }

        #throwZone {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 40%;
            background: linear-gradient(to top, rgba(255,107,107,0.3), transparent);
            border-top: 2px dashed rgba(255,107,107,0.6);
            pointer-events: auto;
            z-index: 50;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        #aimingGrid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 45;
        }

        .grid-line {
            position: absolute;
            background: rgba(255,255,255,0.2);
        }

        .grid-line.vertical {
            width: 1px;
            height: 100%;
            top: 0;
        }

        .grid-line.horizontal {
            height: 1px;
            width: 100%;
            left: 0;
        }
        
        .hidden {
            display: none !important;
        }
        
        #bagOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255,69,0,0.8) 0%, rgba(255,69,0,0.4) 40%, transparent 70%);
            pointer-events: none;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        #throwIndicator {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 20px;
            background: rgba(255,255,255,0.3);
            border-radius: 10px;
            pointer-events: none;
            z-index: 50;
        }
        
        #throwPower {
            height: 100%;
            background: linear-gradient(90deg, #4ECDC4, #FF6B6B);
            border-radius: 10px;
            width: 0%;
            transition: width 0.1s ease;
        }

        #aimingCrosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            border: 2px solid #FF6B6B;
            border-radius: 50%;
            pointer-events: none;
            z-index: 50;
        }

        #aimingCrosshair::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 2px;
            background: #FF6B6B;
        }

        #aimingCrosshair::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 20px;
            background: #FF6B6B;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="ui">
            <div id="score">Score: 0</div>
            <div id="status">Ready to start!</div>
            <div id="instructions" class="hidden">
                ðŸŽ¯ Aim at the hole and calibrate<br>
                ðŸ“± Move phone to aim, thrust forward to throw<br>
                ðŸš€ Watch the grass move as you move!
            </div>
            <div id="debug"></div>
        </div>

        <div id="bagOverlay" class="hidden">
            <div>YOU ARE THE BAG ðŸŽ¯</div>
        </div>
        
        <div id="throwIndicator" class="hidden">
            <div id="throwPower"></div>
        </div>

        <div id="throwZone" class="hidden">
            <div>ðŸŽ¯ TAP HERE TO THROW! ðŸŽ¯</div>
        </div>

        <div id="aimingGrid" class="hidden">
            <div class="grid-line vertical" style="left: 33.33%"></div>
            <div class="grid-line vertical" style="left: 66.66%"></div>
            <div class="grid-line horizontal" style="top: 33.33%"></div>
            <div class="grid-line horizontal" style="top: 66.66%"></div>
        </div>
        
        <button id="startButton">Start Game</button>
        <button id="calibrateButton" class="hidden">Sync Position & Start</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class CalibratedCornhole3D {
            constructor() {
                this.container = document.getElementById('gameContainer');
                this.startButton = document.getElementById('startButton');
                this.calibrateButton = document.getElementById('calibrateButton');
                this.debugDiv = document.getElementById('debug');
                this.statusDiv = document.getElementById('status');
                this.scoreDiv = document.getElementById('score');
                this.instructionsDiv = document.getElementById('instructions');
                this.bagOverlay = document.getElementById('bagOverlay');
                this.throwIndicator = document.getElementById('throwIndicator');
                this.throwPower = document.getElementById('throwPower');
                this.throwZone = document.getElementById('throwZone');
                this.aimingGrid = document.getElementById('aimingGrid');
                
                // Game state
                this.gameStarted = false;
                this.calibrated = false;
                this.aimingMode = false;
                this.score = 0;
                this.throwInProgress = false;
                this.bagView = false;
                this.permissionGranted = false;
                
                // Calibration
                this.calibrationData = {
                    orientation: { alpha: 0, beta: 0, gamma: 0 },
                    acceleration: { x: 0, y: 0, z: 0 }
                };
                
                // Motion detection
                this.motionData = {
                    rawAcceleration: { x: 0, y: 0, z: 0 },
                    calibratedAcceleration: { x: 0, y: 0, z: 0 },
                    velocity: { x: 0, y: 0, z: 0 },
                    orientation: { alpha: 0, beta: 0, gamma: 0 },
                    calibratedOrientation: { alpha: 0, beta: 0, gamma: 0 }
                };
                this.lastTime = Date.now();
                this.throwThreshold = 12; // Higher threshold for more deliberate throws
                this.throwDetected = false;
                this.motionHistory = [];
                this.currentPower = 0;
                this.motionSmoothingFactor = 0.8;
                
                // Three.js setup
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.bag = null;
                this.board = null;
                this.hole = null;
                this.ground = null;
                this.grassTexture = null;
                this.bagStartPosition = new THREE.Vector3(0, 1, 8);
                this.bagPhysics = {
                    velocity: new THREE.Vector3(0, 0, 0),
                    gravity: -0.025,
                    friction: 0.99,
                    bounceReduction: 0.4
                };
                
                this.setupEventListeners();
                this.initThreeJS();
                this.animate();
            }
            
            setupEventListeners() {
                this.startButton.addEventListener('click', () => this.requestPermissions());
                this.calibrateButton.addEventListener('click', () => this.calibrate());
                
                // Add tap to throw as fallback
                this.container.addEventListener('click', (e) => {
                    if (e.target === this.calibrateButton || e.target === this.startButton) return;
                    if (this.bagView && !this.throwInProgress) {
                        this.simulateThrow();
                    }
                });
            }
            
            async requestPermissions() {
                try {
                    this.debug('Requesting permissions...');
                    
                    // Request device motion permission (iOS 13+)
                    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                        this.debug('DeviceMotionEvent.requestPermission exists');
                        const motionPermission = await DeviceMotionEvent.requestPermission();
                        this.debug('Motion permission result: ' + motionPermission);
                        if (motionPermission === 'granted') {
                            this.permissionGranted = true;
                        } else {
                            this.debug('Motion permission denied');
                            this.updateStatus('Motion permission denied. Using tap-to-throw fallback.');
                        }
                    } else {
                        this.debug('DeviceMotionEvent.requestPermission not available');
                        this.permissionGranted = true;
                    }
                    
                    // Request device orientation permission (iOS 13+)
                    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                        this.debug('DeviceOrientationEvent.requestPermission exists');
                        const orientationPermission = await DeviceOrientationEvent.requestPermission();
                        this.debug('Orientation permission result: ' + orientationPermission);
                    } else {
                        this.debug('DeviceOrientationEvent.requestPermission not available');
                    }
                    
                    this.startAiming();
                } catch (error) {
                    this.debug('Permission error: ' + error.message);
                    this.updateStatus('Permission error: ' + error.message);
                    this.startAiming(); // Start anyway with fallback
                }
            }
            
            startAiming() {
                this.startButton.classList.add('hidden');
                this.calibrateButton.classList.remove('hidden');
                this.aimingGrid.classList.remove('hidden');
                this.instructionsDiv.classList.remove('hidden');
                this.aimingMode = true;
                
                // Set camera to aiming position
                this.camera.position.set(0, 1.5, 6);
                this.camera.lookAt(0, 0, -6);
                
                this.updateStatus('Aim at the hole with device tilt, then start!');
                this.enableMotionDetection();
            }
            
            calibrate() {
                this.calibrated = true;
                this.gameStarted = true;
                this.bagView = true;
                this.aimingMode = false;
                
                this.calibrateButton.classList.add('hidden');
                this.aimingGrid.classList.add('hidden');
                this.bagOverlay.classList.remove('hidden');
                this.throwZone.classList.remove('hidden');
                
                this.updateStatus('Tap the throw zone to launch!');
                this.debug('Game started with tap controls');
                
                // Setup enhanced tap throwing
                this.setupTapThrowing();
            }
            
            setupTapThrowing() {
                let tapStartTime = 0;
                let tapPower = 0;
                let powerInterval;
                
                const startPowerCharge = (e) => {
                    e.preventDefault();
                    tapStartTime = Date.now();
                    tapPower = 0;
                    
                    // Start power charging animation
                    powerInterval = setInterval(() => {
                        const elapsed = Date.now() - tapStartTime;
                        tapPower = Math.min(elapsed / 1000, 2.0); // 2 second max charge
                        this.throwPower.style.width = (tapPower * 50) + '%';
                        
                        if (tapPower >= 2.0) {
                            // Auto-throw at max power
                            this.executeEnhancedTapThrow(tapPower);
                            clearInterval(powerInterval);
                        }
                    }, 50);
                };
                
                const executeTapThrow = (e) => {
                    e.preventDefault();
                    clearInterval(powerInterval);
                    
                    if (tapPower === 0) {
                        tapPower = 0.5; // Minimum power for quick taps
                    }
                    
                    this.executeEnhancedTapThrow(tapPower);
                };
                
                // Touch events
                this.throwZone.addEventListener('touchstart', startPowerCharge);
                this.throwZone.addEventListener('touchend', executeTapThrow);
                
                // Mouse events for desktop
                this.throwZone.addEventListener('mousedown', startPowerCharge);
                this.throwZone.addEventListener('mouseup', executeTapThrow);
            }
            
            executeEnhancedTapThrow(power) {
                if (this.throwInProgress) return;
                
                this.throwInProgress = true;
                this.bagView = false;
                
                this.bagOverlay.classList.add('hidden');
                this.throwZone.classList.add('hidden');
                this.throwIndicator.classList.add('hidden');
                
                // Calculate realistic throw based on power and aim
                const throwForce = 0.4 + (power * 0.8); // 0.4 to 1.2 force
                const accuracy = Math.max(0.7, 1.0 - (power * 0.1)); // Less accurate at high power
                
                // Add some randomness based on power
                const randomSpread = (1.0 - accuracy) * 0.6;
                const lateralForce = (Math.random() - 0.5) * randomSpread;
                const upwardForce = 0.4 + (power * 0.4) + (Math.random() - 0.5) * 0.2;
                
                // Apply physics to bag
                this.bagPhysics.velocity.set(
                    lateralForce,
                    upwardForce,
                    -throwForce
                );
                
                this.updateStatus(`Thrown with ${(power * 100).toFixed(0)}% power!`);
                this.debug(`Enhanced throw: power=${power.toFixed(2)}, accuracy=${accuracy.toFixed(2)}`);
                
                this.switchToFollowCamera();
            }
            
            startGrassAnimation() {
                const animateGrass = () => {
                    if (!this.bagView) return;
                    
                    // Move grass texture based on phone movement
                    if (this.grassTexture && this.calibrated) {
                        const moveX = this.motionData.calibratedOrientation.gamma * 0.001;
                        const moveY = this.motionData.calibratedOrientation.beta * 0.001;
                        
                        this.grassTexture.offset.x += moveX;
                        this.grassTexture.offset.y += moveY;
                    }
                    
                    requestAnimationFrame(animateGrass);
                };
                animateGrass();
            }
            
            enableMotionDetection() {
                this.debug('Enabling motion detection...');
                
                if ('DeviceMotionEvent' in window) {
                    this.debug('DeviceMotionEvent supported');
                    window.addEventListener('devicemotion', (event) => {
                        this.handleMotion(event);
                    });
                    
                    // Test if we get any motion data
                    setTimeout(() => {
                        if (this.motionData.rawAcceleration.x === 0 && 
                            this.motionData.rawAcceleration.y === 0 && 
                            this.motionData.rawAcceleration.z === 0) {
                            this.debug('No motion data received - using tap fallback');
                            this.updateStatus('No motion data - tap screen to throw');
                        } else {
                            this.debug('Motion data working!');
                        }
                    }, 2000);
                } else {
                    this.debug('DeviceMotionEvent not supported');
                    this.updateStatus('Device motion not supported - tap to throw');
                }
                
                if ('DeviceOrientationEvent' in window) {
                    this.debug('DeviceOrientationEvent supported');
                    window.addEventListener('deviceorientation', (event) => {
                        this.handleOrientation(event);
                    });
                    
                    // Test if we get any orientation data
                    setTimeout(() => {
                        if (this.motionData.orientation.alpha === 0 && 
                            this.motionData.orientation.beta === 0 && 
                            this.motionData.orientation.gamma === 0) {
                            this.debug('No orientation data received');
                        } else {
                            this.debug('Orientation data working!');
                        }
                    }, 2000);
                } else {
                    this.debug('DeviceOrientationEvent not supported');
                }
            }
            
            handleMotion(event) {
                // Try different ways to get acceleration data
                const acc = event.acceleration || event.accelerationIncludingGravity;
                
                if (!acc) {
                    this.debug('No acceleration data in event');
                    return;
                }
                
                // Log raw data to debug
                if (acc.x !== null || acc.y !== null || acc.z !== null) {
                    this.debug(`Raw motion: x=${(acc.x || 0).toFixed(2)}, y=${(acc.y || 0).toFixed(2)}, z=${(acc.z || 0).toFixed(2)}`);
                }
                
                const now = Date.now();
                const dt = (now - this.lastTime) / 1000;
                this.lastTime = now;
                
                if (dt > 0.1) return; // Skip if too much time has passed
                
                // Store raw acceleration with null checks and smoothing
                const newX = acc.x !== null ? acc.x : 0;
                const newY = acc.y !== null ? acc.y : 0;
                const newZ = acc.z !== null ? acc.z : 0;
                
                this.motionData.rawAcceleration.x = this.motionData.rawAcceleration.x * this.motionSmoothingFactor + newX * (1 - this.motionSmoothingFactor);
                this.motionData.rawAcceleration.y = this.motionData.rawAcceleration.y * this.motionSmoothingFactor + newY * (1 - this.motionSmoothingFactor);
                this.motionData.rawAcceleration.z = this.motionData.rawAcceleration.z * this.motionSmoothingFactor + newZ * (1 - this.motionSmoothingFactor);
                
                // Calculate calibrated acceleration
                if (this.calibrated) {
                    this.motionData.calibratedAcceleration.x = this.motionData.rawAcceleration.x - this.calibrationData.acceleration.x;
                    this.motionData.calibratedAcceleration.y = this.motionData.rawAcceleration.y - this.calibrationData.acceleration.y;
                    this.motionData.calibratedAcceleration.z = this.motionData.rawAcceleration.z - this.calibrationData.acceleration.z;
                    
                    // Calculate velocity from calibrated acceleration
                    this.motionData.velocity.x += this.motionData.calibratedAcceleration.x * dt;
                    this.motionData.velocity.y += this.motionData.calibratedAcceleration.y * dt;
                    this.motionData.velocity.z += this.motionData.calibratedAcceleration.z * dt;
                    
                    // Apply velocity damping
                    this.motionData.velocity.x *= 0.95;
                    this.motionData.velocity.y *= 0.95;
                    this.motionData.velocity.z *= 0.95;
                    
                    // Store motion history
                    this.motionHistory.push({
                        time: now,
                        acc: { ...this.motionData.calibratedAcceleration },
                        vel: { ...this.motionData.velocity }
                    });
                    
                    // Keep only recent history
                    this.motionHistory = this.motionHistory.filter(h => now - h.time < 2000);
                    
                    if (this.bagView) {
                        this.detectThrow();
                        this.updateThrowPower();
                    }
                }
            }
            
            handleOrientation(event) {
                // Log raw orientation data
                this.debug(`Orientation: Î±=${(event.alpha || 0).toFixed(1)}Â° Î²=${(event.beta || 0).toFixed(1)}Â° Î³=${(event.gamma || 0).toFixed(1)}Â°`);
                
                if (event.alpha !== null && event.alpha !== undefined) this.motionData.orientation.alpha = event.alpha;
                if (event.beta !== null && event.beta !== undefined) this.motionData.orientation.beta = event.beta;
                if (event.gamma !== null && event.gamma !== undefined) this.motionData.orientation.gamma = event.gamma;
                
                if (this.calibrated) {
                    this.motionData.calibratedOrientation.alpha = this.motionData.orientation.alpha - this.calibrationData.orientation.alpha;
                    this.motionData.calibratedOrientation.beta = this.motionData.orientation.beta - this.calibrationData.orientation.beta;
                    this.motionData.calibratedOrientation.gamma = this.motionData.orientation.gamma - this.calibrationData.orientation.gamma;
                }
                
                // Update aiming during aiming mode
                if (this.aimingMode) {
                    this.updateAimingView();
                }
            }
            
            updateAimingView() {
                if (!this.aimingMode) return;
                
                // Slightly move camera based on orientation for aiming feedback
                const tiltX = (this.motionData.orientation.gamma || 0) * 0.02;
                const tiltY = (this.motionData.orientation.beta - 90) * 0.02;
                
                this.camera.position.x = Math.max(-1, Math.min(1, tiltX));
                this.camera.position.y = Math.max(0.5, Math.min(2.5, 1.5 + tiltY));
                this.camera.lookAt(0, 0, -6);
            }
            
            updateThrowPower() {
                if (!this.bagView) return;
                
                // Calculate power based on total acceleration magnitude
                const totalAccel = Math.sqrt(
                    Math.pow(this.motionData.calibratedAcceleration.x, 2) +
                    Math.pow(this.motionData.calibratedAcceleration.y, 2) +
                    Math.pow(this.motionData.calibratedAcceleration.z, 2)
                );
                
                this.currentPower = Math.min(totalAccel / this.throwThreshold, 1.0);
                this.throwPower.style.width = (this.currentPower * 100) + '%';
                
                this.debug(`Power: ${(this.currentPower * 100).toFixed(0)}% | Accel: ${totalAccel.toFixed(1)}`);
            }
            
            detectThrow() {
                if (this.motionHistory.length < 10) return;
                
                // Look for strong forward acceleration pattern
                const recentHistory = this.motionHistory.slice(-10);
                const forwardAccels = recentHistory.map(h => Math.abs(h.acc.z));
                const maxForwardAccel = Math.max(...forwardAccels);
                
                // Also check for sudden acceleration spike
                const accelerationSpike = forwardAccels.some(acc => acc > this.throwThreshold);
                
                // Detect throw: strong forward acceleration AND significant change in motion
                if (accelerationSpike && !this.throwDetected) {
                    this.throwDetected = true;
                    this.executeThrow();
                    
                    setTimeout(() => {
                        this.throwDetected = false;
                    }, 2000);
                }
            }
            
            executeThrow() {
                if (this.throwInProgress) return;
                
                this.throwInProgress = true;
                this.bagView = false;
                
                this.bagOverlay.classList.add('hidden');
                this.throwIndicator.classList.add('hidden');
                this.updateStatus('Bag in flight!');
                
                // Calculate throw parameters from motion
                const throwForce = Math.max(0.3, Math.min(this.currentPower * 1.5, 1.2));
                const lateralForce = this.motionData.calibratedAcceleration.x * 0.03;
                const upwardForce = 0.4 + (this.currentPower * 0.3);
                
                // Apply physics to bag
                this.bagPhysics.velocity.set(
                    lateralForce,
                    upwardForce,
                    -throwForce
                );
                
                this.debug(`Throw! Power=${(this.currentPower*100).toFixed(0)}% Force=${throwForce.toFixed(2)}`);
                
                // Switch to follow camera
                this.switchToFollowCamera();
            }
            
            switchToFollowCamera() {
                const followCamera = () => {
                    if (!this.throwInProgress) return;
                    
                    const bagPos = this.bag.position;
                    const targetPos = new THREE.Vector3(
                        bagPos.x + 2,
                        bagPos.y + 1.5,
                        bagPos.z + 4
                    );
                    
                    this.camera.position.lerp(targetPos, 0.08);
                    this.camera.lookAt(bagPos);
                    
                    requestAnimationFrame(followCamera);
                };
                
                followCamera();
            }
            
            simulateThrow() {
                if (this.throwInProgress) return;
                
                this.throwInProgress = true;
                this.bagView = false;
                
                this.bagOverlay.classList.add('hidden');
                this.throwIndicator.classList.add('hidden');
                this.updateStatus('Simulated throw! (Tap-to-throw)');
                
                // Random throw with reasonable parameters
                this.bagPhysics.velocity.set(
                    (Math.random() - 0.5) * 0.4,
                    0.4 + Math.random() * 0.4,
                    -0.6 - Math.random() * 0.6
                );
                
                this.debug('Simulated throw executed');
                this.switchToFollowCamera();
            }
            
            updatePhysics() {
                if (!this.throwInProgress) return;
                
                // Apply gravity
                this.bagPhysics.velocity.y += this.bagPhysics.gravity;
                
                // Apply air resistance
                this.bagPhysics.velocity.multiplyScalar(this.bagPhysics.friction);
                
                // Update bag position
                this.bag.position.add(this.bagPhysics.velocity);
                
                // Add rotation during flight
                this.bag.rotation.x += 0.1;
                this.bag.rotation.z += 0.05;
                
                // Check for landing
                if (this.bag.position.y <= 0.3) {
                    this.handleLanding();
                }
                
                // Check bounds
                if (this.bag.position.z < -15 || Math.abs(this.bag.position.x) > 10) {
                    this.resetBag();
                }
            }
            
            handleLanding() {
                this.bag.position.y = 0.3;
                this.bagPhysics.velocity.set(0, 0, 0);
                
                // Check scoring
                const distanceToHole = Math.sqrt(
                    Math.pow(this.bag.position.x - 0, 2) +
                    Math.pow(this.bag.position.z - (-6), 2)
                );
                
                if (distanceToHole < 1.0) {
                    this.score += 3;
                    this.updateStatus('IN THE HOLE! +3 points! ðŸŽ¯');
                } else if (Math.abs(this.bag.position.x) < 2.2 && this.bag.position.z > -8 && this.bag.position.z < -4) {
                    this.score += 1;
                    this.updateStatus('On the board! +1 point! ðŸ“');
                } else {
                    this.updateStatus('Missed! Try again! ðŸŽ¯');
                }
                
                this.scoreDiv.textContent = `Score: ${this.score}`;
                
                setTimeout(() => {
                    this.resetBag();
                }, 3000);
            }
            
            resetBag() {
                // Reset bag
                this.bag.position.copy(this.bagStartPosition);
                this.bag.rotation.set(0, 0, 0);
                this.bagPhysics.velocity.set(0, 0, 0);
                
                // Reset camera to bag view
                this.camera.position.set(0, 1.5, 6);
                this.camera.lookAt(0, 0, -6);
                
                // Reset state
                this.throwInProgress = false;
                this.bagView = true;
                this.currentPower = 0;
                
                this.bagOverlay.classList.remove('hidden');
                this.throwZone.classList.remove('hidden');
                this.throwPower.style.width = '0%';
                
                this.updateStatus('Tap and hold the throw zone to charge power!');
                
                // Reset motion data
                this.motionData.velocity = { x: 0, y: 0, z: 0 };
                this.motionHistory = [];
            }
            
            initThreeJS() {
                // Create scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB);
                
                // Create camera
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 1.5, 6);
                this.camera.lookAt(0, 0, -6);
                
                // Create renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.container.appendChild(this.renderer.domElement);
                
                // Create lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 10, 5);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);
                
                // Create animated grass ground
                const grassGeometry = new THREE.PlaneGeometry(20, 20);
                
                // Create grass texture pattern
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 512;
                const ctx = canvas.getContext('2d');
                
                // Create grass pattern
                ctx.fillStyle = '#228B22';
                ctx.fillRect(0, 0, 512, 512);
                
                // Add grass texture details
                for (let i = 0; i < 1000; i++) {
                    const x = Math.random() * 512;
                    const y = Math.random() * 512;
                    const shade = Math.random() * 0.3 + 0.7;
                    ctx.fillStyle = `rgb(${Math.floor(34 * shade)}, ${Math.floor(139 * shade)}, ${Math.floor(34 * shade)})`;
                    ctx.fillRect(x, y, 2, 8);
                }
                
                this.grassTexture = new THREE.CanvasTexture(canvas);
                this.grassTexture.wrapS = THREE.RepeatWrapping;
                this.grassTexture.wrapT = THREE.RepeatWrapping;
                this.grassTexture.repeat.set(4, 4);
                
                const grassMaterial = new THREE.MeshLambertMaterial({ map: this.grassTexture });
                this.ground = new THREE.Mesh(grassGeometry, grassMaterial);
                this.ground.rotation.x = -Math.PI / 2;
                this.ground.receiveShadow = true;
                this.scene.add(this.ground);
                
                // Create cornhole board
                const boardGeometry = new THREE.BoxGeometry(4, 0.2, 2);
                const boardMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                this.board = new THREE.Mesh(boardGeometry, boardMaterial);
                this.board.position.set(0, 0.1, -6);
                this.board.castShadow = true;
                this.board.receiveShadow = true;
                this.scene.add(this.board);
                
                // Create hole
                const holeGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.3, 16);
                const holeMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
                this.hole = new THREE.Mesh(holeGeometry, holeMaterial);
                this.hole.position.set(0, 0.05, -6);
                this.scene.add(this.hole);
                
                // Add hole rim for better visibility
                const rimGeometry = new THREE.RingGeometry(0.8, 0.9, 16);
                const rimMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
                const rim = new THREE.Mesh(rimGeometry, rimMaterial);
                rim.position.set(0, 0.21, -6);
                rim.rotation.x = -Math.PI / 2;
                this.scene.add(rim);
                
                // Create bag
                const bagGeometry = new THREE.BoxGeometry(0.6, 0.2, 0.6);
                const bagMaterial = new THREE.MeshLambertMaterial({ color: 0xFF4500 });
                this.bag = new THREE.Mesh(bagGeometry, bagMaterial);
                this.bag.position.copy(this.bagStartPosition);
                this.bag.castShadow = true;
                this.scene.add(this.bag);
                
                // Handle window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                this.updatePhysics();
                this.renderer.render(this.scene, this.camera);
            }
            
            updateStatus(message) {
                this.statusDiv.textContent = message;
            }
            
            debug(message) {
                const now = new Date().toLocaleTimeString();
                this.debugDiv.innerHTML = `[${now}] ${message}<br>` + this.debugDiv.innerHTML;
                
                const lines = this.debugDiv.innerHTML.split('<br>');
                if (lines.length > 6) {
                    this.debugDiv.innerHTML = lines.slice(0, 6).join('<br>');
                }
            }
        }
        
        // Start the game when page loads
        window.addEventListener('load', () => {
            new CalibratedCornhole3D();
        });
    </script>
</body>
</html>
